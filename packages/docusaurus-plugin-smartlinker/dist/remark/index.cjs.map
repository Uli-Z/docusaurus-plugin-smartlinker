{"version":3,"sources":["../../src/pluginName.ts","../../src/options.ts","../../src/frontmatter.ts","../../src/indexProviderStore.ts","../../src/logger.ts","../../src/debugStore.ts","../../src/index.ts","../../../remark-smartlinker/src/matcher.ts","../../../remark-smartlinker/src/transform.ts","../../src/remark/index.ts"],"names":["z","GLOBAL_KEY","dirname","fileURLToPath","name","visit","SKIP","normalize","buildMatcher","remarkSmartlinker"],"mappings":"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","file":"index.cjs","sourcesContent":["export const PLUGIN_NAME = 'docusaurus-plugin-smartlinker';\nexport const DEFAULT_PLUGIN_ID = 'default';\n","import { z } from 'zod';\nimport { PLUGIN_NAME } from './pluginName.js';\n\nconst TrimmedString = z\n  .string()\n  .transform((value) => value.trim())\n  .refine((value) => value.length > 0, {\n    message: 'Expected a non-empty string',\n  });\n\nconst TooltipComponentSchema = z.union([\n  TrimmedString,\n  z.object({\n    path: TrimmedString,\n    export: TrimmedString.optional(),\n  }),\n]);\n\nconst DebugLevelSchema = z.enum(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DebugOptionsSchema = z\n  .object({\n    enabled: z.boolean().default(false),\n    level: DebugLevelSchema.default('warn'),\n  })\n  .default({ enabled: false, level: 'warn' });\n\nexport type TooltipComponentConfig = {\n  importPath: string;\n  exportName?: string;\n};\n\nconst TooltipComponentsRecord = z\n  .record(TooltipComponentSchema)\n  .default({})\n  .transform((value) => {\n    const out: Record<string, TooltipComponentConfig> = {};\n    for (const [alias, spec] of Object.entries(value)) {\n      const key = alias.trim();\n      if (!key) continue;\n      if (typeof spec === 'string') {\n        out[key] = { importPath: spec };\n      } else {\n        out[key] = {\n          importPath: spec.path,\n          exportName: spec.export ?? undefined,\n        };\n      }\n    }\n    return out;\n  });\n\nconst FolderSchema = z.object({\n  path: TrimmedString,\n  defaultIcon: TrimmedString.optional(),\n  tooltipComponents: TooltipComponentsRecord,\n});\n\nexport const OptionsSchema = z\n  .object({\n    icons: z.record(TrimmedString).default({}),\n    darkModeIcons: z.record(TrimmedString).optional(),\n    iconProps: z.record(z.unknown()).optional(),\n    folders: z.array(FolderSchema).default([]),\n    debug: DebugOptionsSchema,\n  })\n  .transform((value) => {\n    const aggregated: Record<string, TooltipComponentConfig> = {};\n    for (const folder of value.folders) {\n      for (const [alias, spec] of Object.entries(folder.tooltipComponents)) {\n        if (aggregated[alias]) continue;\n        aggregated[alias] = spec;\n      }\n    }\n    return { ...value, tooltipComponents: aggregated };\n  });\n\nexport type PluginOptions = z.input<typeof OptionsSchema>;\nexport type NormalizedFolderOption = z.output<typeof FolderSchema>;\nexport type NormalizedOptions = z.output<typeof OptionsSchema>;\nexport type DebugOptions = z.output<typeof DebugOptionsSchema>;\n\nexport type OptionsWarning = {\n  code:\n    | 'FOLDERS_REQUIRED'\n    | 'FOLDER_PATH_DUPLICATE'\n    | 'FOLDER_DEFAULT_ICON_UNKNOWN'\n    | 'FOLDER_TOOLTIP_COMPONENT_ALIAS_EMPTY'\n    | 'DARK_MODE_ICON_UNKNOWN'\n    | 'ICON_ID_EMPTY'\n    | 'EMPTY_ICONS_OBJECT'\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ValidationResult = {\n  options: NormalizedOptions;\n  warnings: OptionsWarning[];\n};\n\n/**\n * Validate and normalize plugin options without side effects.\n * - Ensures objects exist\n * - Adds structured warnings for common misconfigurations\n */\nexport function validateOptions(input: PluginOptions | undefined): ValidationResult {\n  const parsed = OptionsSchema.safeParse(input ?? {});\n  if (!parsed.success) {\n    // Should be rare; Zod already guards shapes.\n    return {\n      options: {\n        icons: {},\n        tooltipComponents: {},\n        folders: [],\n        debug: { enabled: false, level: 'warn' },\n      },\n      warnings: [{\n        code: 'EMPTY_ICONS_OBJECT',\n        message: 'Invalid options; falling back to empty configuration.',\n        details: { issues: parsed.error.issues.map(i => ({ path: i.path, message: i.message })) }\n      }]\n    };\n  }\n\n  const options = parsed.data;\n  const rawFoldersInput: unknown[] = Array.isArray((input as any)?.folders)\n    ? (input as any).folders\n    : [];\n  const warnings: OptionsWarning[] = [];\n\n  // Warn if icons is totally empty (harmless but often unintended)\n  if (!options.icons || Object.keys(options.icons).length === 0) {\n    warnings.push({\n      code: 'EMPTY_ICONS_OBJECT',\n      message: '`icons` is empty; links will render without icons unless pages specify one later and a default is set.',\n    });\n  }\n\n  // Dark-mode overrides should reference existing icon ids\n  if (options.darkModeIcons) {\n    for (const id of Object.keys(options.darkModeIcons)) {\n      if (!options.icons[id]) {\n        warnings.push({\n          code: 'DARK_MODE_ICON_UNKNOWN',\n          message: 'darkModeIcons contains an id not present in `icons`.',\n          details: { id }\n        });\n      }\n    }\n  }\n\n  // Basic sanity: no empty string ids in icons\n  for (const id of Object.keys(options.icons)) {\n    if (!id.trim()) {\n      warnings.push({\n        code: 'ICON_ID_EMPTY',\n        message: 'An icon id is an empty string.',\n      });\n    }\n  }\n\n  if (options.folders.length === 0) {\n    warnings.push({\n      code: 'FOLDERS_REQUIRED',\n      message: '`folders` must list at least one directory to scan.',\n    });\n  }\n\n  const seenFolderPaths = new Map<string, number>();\n  options.folders.forEach((folder, index) => {\n    const normalizedPathRaw = folder.path.replace(/\\\\/g, '/').replace(/\\/+$/, '');\n    const normalizedPath = normalizedPathRaw || '.';\n    const seenCount = seenFolderPaths.get(normalizedPath) ?? 0;\n    if (seenCount > 0) {\n      warnings.push({\n        code: 'FOLDER_PATH_DUPLICATE',\n        message: 'Duplicate folder configuration detected.',\n        details: { path: normalizedPath },\n      });\n    }\n    seenFolderPaths.set(normalizedPath, seenCount + 1);\n\n    if (folder.defaultIcon && !options.icons[folder.defaultIcon]) {\n      warnings.push({\n        code: 'FOLDER_DEFAULT_ICON_UNKNOWN',\n        message: '`defaultIcon` refers to an unknown icon id.',\n        details: { path: normalizedPath, defaultIcon: folder.defaultIcon },\n      });\n    }\n\n    const rawFolder = rawFoldersInput[index];\n    const rawTooltip = rawFolder && typeof rawFolder === 'object'\n      ? (rawFolder as any).tooltipComponents\n      : undefined;\n    if (rawTooltip && typeof rawTooltip === 'object') {\n      for (const alias of Object.keys(rawTooltip)) {\n        if (!String(alias).trim()) {\n          warnings.push({\n            code: 'FOLDER_TOOLTIP_COMPONENT_ALIAS_EMPTY',\n            message: '`tooltipComponents` contains a component key that is empty.',\n            details: { path: normalizedPath },\n          });\n        }\n      }\n    }\n  });\n\n  return { options, warnings };\n}\n\nexport type IconResolution = {\n  /** the chosen icon id (logical id), or null if none is applicable */\n  iconId: string | null;\n  /** returns the concrete asset path for the chosen id & mode */\n  src: string | null;\n};\n\n/**\n * Create resolvers bound to normalized options.\n * Pure & stateless: call per need. You can also call resolve* directly with `opts`.\n */\nexport function createIconResolver(opts: NormalizedOptions) {\n  const warnedMissingIds = new Set<string>();\n\n  const warnMissingIcon = (id: string) => {\n    if (warnedMissingIds.has(id)) {\n      return;\n    }\n    warnedMissingIds.add(id);\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `[${PLUGIN_NAME}] Requested icon \"${id}\" is not configured. The link will render without that icon.`,\n      );\n    }\n  };\n\n  function resolveIconId(requestedId?: string, mode: 'light' | 'dark' = 'light'): IconResolution {\n    // Helper to compute path if we have a final id\n    const toSrc = (id: string, modeIn: 'light' | 'dark'): string | null => {\n      const override = modeIn === 'dark' ? opts.darkModeIcons?.[id] : undefined;\n      const path = override ?? opts.icons[id];\n      return typeof path === 'string' ? path : null;\n    };\n\n    if (requestedId) {\n      if (opts.icons[requestedId]) {\n        const src = toSrc(requestedId, mode);\n        return { iconId: requestedId, src };\n      }\n      warnMissingIcon(requestedId);\n    }\n\n    return { iconId: null, src: null };\n  }\n\n  function resolveIconSrc(iconId: string, mode: 'light' | 'dark' = 'light'): string | null {\n    const override = mode === 'dark' ? opts.darkModeIcons?.[iconId] : undefined;\n    const path = override ?? opts.icons[iconId];\n    if (!opts.icons[iconId]) {\n      warnMissingIcon(iconId);\n    }\n    return typeof path === 'string' ? path : null;\n  }\n\n  return { resolveIconId, resolveIconSrc, iconProps: opts.iconProps ?? {} };\n}\n","import matter from 'gray-matter';\nimport { z } from 'zod';\nimport type {\n  RawDocFile,\n  FrontmatterParseResult,\n  IndexRawEntry,\n  FrontmatterWarning,\n} from './types.js';\n\nconst SupportedExt = new Set(['.md', '.mdx']);\n\nconst FM = z.object({\n  id: z.string().optional(),\n  slug: z.string().optional(),\n  title: z.string().optional(),\n  'smartlink-terms': z.array(z.string()).optional(),\n  linkify: z.boolean().optional(),\n  'smartlink-icon': z.string().optional(),\n  'smartlink-short-note': z.string().optional()\n});\n\nfunction isSupportedExt(path: string, extOverride?: string): boolean {\n  const ext = (extOverride ?? path.slice(path.lastIndexOf('.'))).toLowerCase();\n  return SupportedExt.has(ext as any);\n}\n\nfunction normalizeSmartlinkTerms(list: unknown[]): string[] {\n  const seen = new Set<string>();\n  const terms: string[] = [];\n  for (const value of list) {\n    if (typeof value !== 'string') continue;\n    const trimmed = value.trim();\n    if (!trimmed) continue;\n    const key = trimmed.toLocaleLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    terms.push(trimmed);\n  }\n  return terms;\n}\n\nfunction pickRelativeCandidate(file: RawDocFile): string | null {\n  if (typeof file.relativePath === 'string' && file.relativePath.trim()) {\n    return file.relativePath.trim();\n  }\n  if (typeof file.path === 'string' && file.path.trim()) {\n    const normalized = file.path.replace(/\\\\/g, '/');\n    const idx = normalized.lastIndexOf('/');\n    return idx >= 0 ? normalized.slice(idx + 1) : normalized;\n  }\n  return null;\n}\n\nfunction inferDefaultSlug(file: RawDocFile): string | null {\n  const candidate = pickRelativeCandidate(file);\n  if (!candidate) return null;\n\n  const normalized = candidate.replace(/\\\\/g, '/');\n  const withoutLeading = normalized.replace(/^\\.+\\/+/, '').replace(/^\\/+/, '');\n  const collapsed = withoutLeading.replace(/\\/+/g, '/');\n  const withoutExt = collapsed.replace(/\\.[^./]+$/, '');\n  const trimmed = withoutExt.replace(/\\/+$/, '');\n  if (!trimmed) return null;\n  return `/${trimmed}`;\n}\n\nexport function parseFrontmatter(files: RawDocFile[]): FrontmatterParseResult {\n  const entries: IndexRawEntry[] = [];\n  const warnings: FrontmatterWarning[] = [];\n\n  for (const file of files) {\n    if (!isSupportedExt(file.path, file.ext)) {\n      warnings.push({\n        path: file.path,\n        code: 'UNSUPPORTED_EXT',\n        message: 'Unsupported extension (only .md/.mdx are processed).'\n      });\n      continue;\n    }\n\n    try {\n      const { data } = matter(file.content ?? '');\n      const res = FM.safeParse(data ?? {});\n      if (!res.success) {\n        warnings.push({\n          path: file.path,\n          code: 'INVALID_TYPE',\n          message: 'Frontmatter has invalid shape.',\n          details: { issues: res.error.issues.map(i => ({ path: i.path, message: i.message })) }\n        });\n        continue;\n      }\n\n      const fm = res.data;\n\n      const linkify = fm.linkify ?? true;\n      if (!linkify) {\n        warnings.push({\n          path: file.path,\n          code: 'LINKIFY_FALSE',\n          message: '`linkify:false` – skipped from index.'\n        });\n        continue;\n      }\n\n      const hasSmartlinkTermsField = Object.prototype.hasOwnProperty.call(fm, 'smartlink-terms');\n      const smartlinkTermsRaw = (fm as any)['smartlink-terms'];\n\n      if (!hasSmartlinkTermsField || typeof smartlinkTermsRaw === 'undefined') {\n        continue;\n      }\n\n      if (!Array.isArray(smartlinkTermsRaw)) {\n        warnings.push({\n          path: file.path,\n          code: 'INVALID_TYPE',\n          message: '`smartlink-terms` must be an array of strings.'\n        });\n        continue;\n      }\n\n      const terms = normalizeSmartlinkTerms(smartlinkTermsRaw);\n      if (terms.length === 0) {\n        warnings.push({\n          path: file.path,\n          code: 'EMPTY_SMARTLINK_TERMS',\n          message: '`smartlink-terms` must include at least one non-empty string.'\n        });\n        continue;\n      }\n\n      const id = (fm.id ?? '').trim();\n      if (!id) {\n        warnings.push({\n          path: file.path,\n          code: 'EMPTY_ID',\n          message: 'Missing required `id`.'\n        });\n        continue;\n      }\n\n      let slug = (fm.slug ?? '').trim();\n      if (!slug) {\n        slug = inferDefaultSlug(file) ?? '';\n      }\n      if (!slug) {\n        warnings.push({\n          path: file.path,\n          code: 'MISSING_REQUIRED',\n          message: 'Unable to determine slug – please add a `slug` or ensure file path can be inferred.'\n        });\n        continue;\n      }\n      if (!slug.startsWith('/')) {\n        warnings.push({\n          path: file.path,\n          code: 'INVALID_TYPE',\n          message: '`slug` must start with `/`.',\n          details: { slug }\n        });\n        continue;\n      }\n\n      const shortRaw = typeof (fm as any)['smartlink-short-note'] === 'string'\n        ? (fm as any)['smartlink-short-note'].trim()\n        : '';\n      const shortNote = shortRaw ? shortRaw : undefined;\n\n      const iconRaw = typeof (fm as any)['smartlink-icon'] === 'string'\n        ? (fm as any)['smartlink-icon'].trim()\n        : '';\n      const icon = iconRaw ? iconRaw : undefined;\n\n      entries.push({\n        id,\n        slug,\n        terms,\n        linkify: true,\n        icon,\n        shortNote,\n        sourcePath: file.path,\n        folderId: file.folderId\n      });\n    } catch (err: any) {\n      warnings.push({\n        path: file.path,\n        code: 'INVALID_TYPE',\n        message: 'Failed to parse frontmatter.',\n        details: { error: String(err?.message ?? err) }\n      });\n      continue;\n    }\n  }\n\n  return { entries, warnings };\n}\n","import type { IndexRawEntry } from './types.js';\nimport type { IndexProvider, TargetInfo } from './fsIndexProvider.js';\n\nconst GLOBAL_KEY = Symbol.for('docusaurus-plugin-smartlinker.indexProvider');\n\nlet currentProvider: IndexProvider | undefined;\n\nfunction readGlobalProvider(): IndexProvider | undefined {\n  const store = globalThis as Record<PropertyKey, unknown>;\n  const value = store[GLOBAL_KEY];\n  if (value && typeof value === 'object') {\n    return value as IndexProvider;\n  }\n  return undefined;\n}\n\nfunction writeGlobalProvider(provider: IndexProvider | undefined): void {\n  const store = globalThis as Record<PropertyKey, unknown>;\n  if (!provider) {\n    delete store[GLOBAL_KEY];\n  } else {\n    store[GLOBAL_KEY] = provider;\n  }\n}\n\nfunction toTargets(entries: IndexRawEntry[]): TargetInfo[] {\n  return entries.map((entry) => ({\n    id: entry.id,\n    slug: entry.slug,\n    icon: entry.icon,\n    sourcePath: entry.sourcePath,\n    terms: entry.terms,\n    folderId: entry.folderId ?? null,\n  }));\n}\n\nexport function setIndexEntries(entries: IndexRawEntry[]): void {\n  const targets = toTargets(entries);\n\n  currentProvider = {\n    getAllTargets() {\n      return targets;\n    },\n    getCurrentFilePath(file) {\n      if (file && typeof file.path === 'string') {\n        return file.path;\n      }\n      return '';\n    },\n  };\n\n  writeGlobalProvider(currentProvider);\n}\n\nexport function getIndexProvider(): IndexProvider | undefined {\n  return currentProvider ?? readGlobalProvider();\n}\n\nexport function clearIndexProvider(): void {\n  currentProvider = undefined;\n  writeGlobalProvider(undefined);\n}\n","import type { DebugOptions } from './options.js';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';\n\nconst LOG_LEVELS: readonly LogLevel[] = ['error', 'warn', 'info', 'debug', 'trace'];\nconst LEVEL_RANK: Record<LogLevel, number> = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4,\n};\n\nconst LEVEL_COLORS: Record<LogLevel, string> = {\n  error: '\\u001b[31m',\n  warn: '\\u001b[33m',\n  info: '\\u001b[36m',\n  debug: '\\u001b[35m',\n  trace: '\\u001b[90m',\n};\n\nconst COLOR_RESET = '\\u001b[0m';\n\ntype LogDetailRecord = Record<string, unknown>;\ntype LogDetails = LogDetailRecord | (() => LogDetailRecord | undefined) | undefined;\n\ntype ConsoleMethod = (message?: any, ...optionalParams: any[]) => void;\n\nexport interface LoggerInit {\n  pluginName: string;\n  debug: DebugOptions;\n  /**\n   * Optionally override the process environment (used for tests).\n   */\n  env?: NodeJS.ProcessEnv;\n  /**\n   * Optionally override the timestamp factory (used for tests).\n   */\n  now?: () => Date;\n}\n\nexport interface PluginLogger {\n  level: LogLevel;\n  isLevelEnabled(level: LogLevel): boolean;\n  log(level: LogLevel, context: string, message: string, details?: LogDetails): void;\n  error(context: string, message: string, details?: LogDetails): void;\n  warn(context: string, message: string, details?: LogDetails): void;\n  info(context: string, message: string, details?: LogDetails): void;\n  debug(context: string, message: string, details?: LogDetails): void;\n  trace(context: string, message: string, details?: LogDetails): void;\n  child(context: string): ContextLogger;\n}\n\nexport interface ContextLogger {\n  context: string;\n  level: LogLevel;\n  isLevelEnabled(level: LogLevel): boolean;\n  log(level: LogLevel, message: string, details?: LogDetails): void;\n  error(message: string, details?: LogDetails): void;\n  warn(message: string, details?: LogDetails): void;\n  info(message: string, details?: LogDetails): void;\n  debug(message: string, details?: LogDetails): void;\n  trace(message: string, details?: LogDetails): void;\n}\n\nexport interface DebugResolution {\n  config: DebugOptions;\n  source: 'config' | 'env';\n  appliedOverrides: {\n    enabled?: boolean;\n    level?: LogLevel;\n  };\n  invalidLevel?: string;\n}\n\nfunction normalizeBoolean(value: string): boolean {\n  const normalized = value.trim().toLowerCase();\n  if (!normalized) {\n    return false;\n  }\n  if (['0', 'false', 'no', 'off', 'disable', 'disabled'].includes(normalized)) {\n    return false;\n  }\n  if (['1', 'true', 'yes', 'on', 'enable', 'enabled'].includes(normalized)) {\n    return true;\n  }\n  return true;\n}\n\nfunction normalizeLevel(value: string): LogLevel | undefined {\n  const normalized = value.trim().toLowerCase();\n  if (LOG_LEVELS.includes(normalized as LogLevel)) {\n    return normalized as LogLevel;\n  }\n  return undefined;\n}\n\nfunction shouldUseColor(env: NodeJS.ProcessEnv | undefined): boolean {\n  if (typeof process === 'undefined') {\n    return false;\n  }\n  const stdout: typeof process.stdout | undefined = (process as any).stdout;\n  if (!stdout || typeof stdout.isTTY !== 'boolean') {\n    return false;\n  }\n  if (!stdout.isTTY) {\n    return false;\n  }\n  const ci = env?.CI ?? process.env?.CI;\n  if (typeof ci === 'string' && ci !== '' && ci !== '0' && ci.toLowerCase() !== 'false') {\n    return false;\n  }\n  return true;\n}\n\nfunction getConsoleMethod(level: LogLevel): ConsoleMethod {\n  if (level === 'error' && typeof console.error === 'function') {\n    return console.error.bind(console);\n  }\n  if (level === 'warn' && typeof console.warn === 'function') {\n    return console.warn.bind(console);\n  }\n  return typeof console.log === 'function' ? console.log.bind(console) : () => {};\n}\n\nfunction formatFieldValue(value: unknown): string | undefined {\n  if (value === undefined) {\n    return undefined;\n  }\n  if (value === null) {\n    return 'null';\n  }\n  if (typeof value === 'string') {\n    if (!value) {\n      return \"''\";\n    }\n    if (/\\s/.test(value) || /[\"'\\\\]/.test(value)) {\n      return JSON.stringify(value);\n    }\n    return value;\n  }\n  if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {\n    return String(value);\n  }\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return String(value);\n  }\n}\n\nfunction formatDetails(details: LogDetailRecord | undefined): string {\n  if (!details) {\n    return '';\n  }\n  const parts: string[] = [];\n  for (const [key, rawValue] of Object.entries(details)) {\n    const formatted = formatFieldValue(rawValue);\n    if (formatted === undefined) continue;\n    parts.push(`${key}=${formatted}`);\n  }\n  return parts.length > 0 ? ` ${parts.join(' ')}` : '';\n}\n\nfunction resolveDetails(details: LogDetails): LogDetailRecord | undefined {\n  if (!details) {\n    return undefined;\n  }\n  if (typeof details === 'function') {\n    try {\n      return details();\n    } catch {\n      return undefined;\n    }\n  }\n  return details;\n}\n\nexport function resolveDebugConfig(\n  base: DebugOptions | undefined,\n  env: NodeJS.ProcessEnv = process.env,\n): DebugResolution {\n  const fallback: DebugOptions = base ?? { enabled: false, level: 'warn' };\n  let enabled = fallback.enabled ?? false;\n  let level: LogLevel = (fallback.level as LogLevel) ?? 'warn';\n  let source: DebugResolution['source'] = 'config';\n  const appliedOverrides: DebugResolution['appliedOverrides'] = {};\n  let invalidLevel: string | undefined;\n\n  const envEnabledRaw = env?.DOCUSAURUS_PLUGIN_DEBUG;\n  if (typeof envEnabledRaw === 'string') {\n    enabled = normalizeBoolean(envEnabledRaw);\n    appliedOverrides.enabled = enabled;\n    source = 'env';\n  }\n\n  const envLevelRaw = env?.DOCUSAURUS_PLUGIN_DEBUG_LEVEL;\n  if (typeof envLevelRaw === 'string') {\n    const normalized = normalizeLevel(envLevelRaw);\n    if (normalized) {\n      level = normalized;\n      appliedOverrides.level = normalized;\n      source = 'env';\n    } else {\n      invalidLevel = envLevelRaw;\n    }\n  }\n\n  if (!LOG_LEVELS.includes(level)) {\n    level = 'warn';\n  }\n\n  return {\n    config: { enabled, level },\n    source,\n    appliedOverrides,\n    invalidLevel,\n  };\n}\n\nexport function createLogger(init: LoggerInit): PluginLogger {\n  const { pluginName, debug } = init;\n  const env = init.env ?? process.env;\n  const now = init.now ?? (() => new Date());\n\n  const active = Boolean(debug?.enabled);\n  const thresholdLevel: LogLevel = (debug?.level as LogLevel) ?? 'warn';\n  const threshold = LEVEL_RANK[thresholdLevel] ?? LEVEL_RANK.warn;\n  const colorize = shouldUseColor(env);\n\n  const isLevelEnabled = (level: LogLevel): boolean => {\n    if (!active) return false;\n    return LEVEL_RANK[level] <= threshold;\n  };\n\n  const write = (level: LogLevel, context: string, message: string, details?: LogDetails) => {\n    if (!isLevelEnabled(level)) {\n      return;\n    }\n    const consoleMethod = getConsoleMethod(level);\n    const timestamp = now().toISOString();\n    const levelTag = `[${level.toUpperCase()}]`;\n    const coloredLevel = colorize ? `${LEVEL_COLORS[level]}${levelTag}${COLOR_RESET}` : levelTag;\n    const pluginTag = `[${pluginName}]`;\n    const contextTag = context ? ` [${context}]` : '';\n    const resolvedDetails = resolveDetails(details);\n    const detailStr = formatDetails(resolvedDetails);\n    const line = `${timestamp} ${coloredLevel} ${pluginTag}${contextTag} ${message}${detailStr}`.trimEnd();\n    consoleMethod(line);\n  };\n\n  const log = (level: LogLevel, context: string, message: string, details?: LogDetails) => {\n    write(level, context, message, details);\n  };\n\n  const makeLevelLogger = (level: LogLevel) => {\n    return (context: string, message: string, details?: LogDetails) => {\n      log(level, context, message, details);\n    };\n  };\n\n  const child = (context: string): ContextLogger => {\n    const scopedLog = (level: LogLevel, message: string, details?: LogDetails) => {\n      log(level, context, message, details);\n    };\n    const makeScoped = (level: LogLevel) => {\n      return (message: string, details?: LogDetails) => {\n        scopedLog(level, message, details);\n      };\n    };\n    return {\n      context,\n      level: thresholdLevel,\n      isLevelEnabled,\n      log: scopedLog,\n      error: makeScoped('error'),\n      warn: makeScoped('warn'),\n      info: makeScoped('info'),\n      debug: makeScoped('debug'),\n      trace: makeScoped('trace'),\n    };\n  };\n\n  return {\n    level: thresholdLevel,\n    isLevelEnabled,\n    log,\n    error: makeLevelLogger('error'),\n    warn: makeLevelLogger('warn'),\n    info: makeLevelLogger('info'),\n    debug: makeLevelLogger('debug'),\n    trace: makeLevelLogger('trace'),\n    child,\n  };\n}\n","import type { DebugOptions } from './options.js';\n\nconst GLOBAL_KEY = Symbol.for('docusaurus-plugin-smartlinker.debug');\n\nexport function setDebugConfig(config: DebugOptions | undefined): void {\n  const store = globalThis as Record<PropertyKey, unknown>;\n  if (!config) {\n    delete store[GLOBAL_KEY];\n  } else {\n    store[GLOBAL_KEY] = config;\n  }\n}\n\nexport function getDebugConfig(): DebugOptions | undefined {\n  const store = globalThis as Record<PropertyKey, unknown>;\n  const value = store[GLOBAL_KEY];\n  if (value && typeof value === 'object') return value as DebugOptions;\n  return undefined;\n}\n\n","import { dirname, join, resolve, relative, isAbsolute } from 'node:path';\nimport { readdirSync, readFileSync, statSync } from 'node:fs';\nimport { Buffer } from 'node:buffer';\nimport { fileURLToPath } from 'node:url';\nimport { performance } from 'node:perf_hooks';\nimport type { Plugin } from '@docusaurus/types';\nimport type { LoadContext, PluginContentLoadedActions } from '@docusaurus/types';\nimport {\n  validateOptions,\n  type PluginOptions,\n  type NormalizedOptions,\n  type NormalizedFolderOption,\n} from './options.js';\nimport { scanMdFiles } from './node/fsScan.js';\nimport { buildArtifacts } from './node/buildPipeline.js';\nimport type { IndexRawEntry, RawDocFile } from './types.js';\nimport type { NoteModule } from './codegen/notesEmitter.js';\nimport type { RegistryModule } from './codegen/registryEmitter.js';\nimport { emitTooltipComponentsModule } from './codegen/tooltipComponentsEmitter.js';\nimport { PLUGIN_NAME } from './pluginName.js';\nimport { createTooltipMdxCompiler } from './node/tooltipMdxCompiler.js';\nimport { setIndexEntries } from './indexProviderStore.js';\nimport { loadIndexFromFiles } from './frontmatterAdapter.js';\nimport { resolveEntryPermalinks, type EntryWithResolvedUrl } from './node/permalinkResolver.js';\nimport type { LoadedContent as DocsLoadedContent } from '@docusaurus/plugin-content-docs';\nimport { resolveDebugConfig, createLogger, type LogLevel } from './logger.js';\nimport { setDebugConfig } from './debugStore.js';\n\nexport type {\n  FsIndexProviderOptions,\n  IndexProvider,\n  TargetInfo,\n} from './fsIndexProvider.js';\nexport { createFsIndexProvider } from './fsIndexProvider.js';\nexport { PLUGIN_NAME } from './pluginName.js';\nexport { getIndexProvider } from './indexProviderStore.js';\n// Re-export logger utilities for reuse by the remark package\nexport { resolveDebugConfig, createLogger, type LogLevel } from './logger.js';\nexport type { DebugOptions } from './options.js';\nexport { getDebugConfig, setDebugConfig } from './debugStore.js';\n\nexport type { PluginOptions } from './options.js';\n\ntype Content = {\n  entries: IndexRawEntry[];\n  notes: NoteModule[];\n  registry: RegistryModule;\n  opts: NormalizedOptions;\n};\n\ntype ResolvedFolder = NormalizedFolderOption & {\n  absPath: string;\n  id: string;\n};\n\nfunction normalizeFolderId(siteDir: string, absPath: string): string {\n  const relPath = relative(siteDir, absPath);\n  const useRelative =\n    relPath &&\n    !relPath.startsWith('..') &&\n    !isAbsolute(relPath);\n  const candidate = useRelative ? relPath : absPath;\n  const normalized = candidate.replace(/\\\\/g, '/').replace(/\\/+$/, '');\n  return normalized || '.';\n}\n\nconst moduleDir = dirname(fileURLToPath(import.meta.url));\nconst pluginName = PLUGIN_NAME;\n\nfunction publishGlobalData(\n  actions: PluginContentLoadedActions,\n  opts: NormalizedOptions,\n  entries: EntryWithResolvedUrl[],\n) {\n  const registryMeta = entries.map(({ id, slug, icon, folderId, docId, permalink }) => ({\n    id,\n    slug,\n    icon: icon ?? null,\n    folderId: folderId ?? null,\n    docId: docId ?? null,\n    permalink: permalink ?? null,\n  }));\n\n  actions.setGlobalData({ options: opts, entries: registryMeta });\n}\n\nexport default function smartlinkerPlugin(\n  _context: LoadContext,\n  optsIn?: PluginOptions\n): Plugin<Content> {\n  const { options: validatedOptions, warnings } = validateOptions(optsIn);\n  const debugResolution = resolveDebugConfig(validatedOptions.debug);\n  const normOpts: NormalizedOptions = {\n    ...validatedOptions,\n    debug: debugResolution.config,\n  };\n\n  // Make debug configuration available globally so the remark transformer\n  // can mirror the same logging behavior without separate config.\n  setDebugConfig(normOpts.debug);\n\n  if (normOpts.folders.length === 0) {\n    throw new Error(\n      `[${pluginName}] Configure at least one folder via the \\`folders\\` option.`\n    );\n  }\n\n  const logger = createLogger({ pluginName, debug: normOpts.debug });\n  const initLogger = logger.child('init');\n  const optionsLogger = logger.child('options');\n  const scanLogger = logger.child('scan');\n  const indexLogger = logger.child('index');\n  const loadLogger = logger.child('loadContent');\n  const contentLogger = logger.child('contentLoaded');\n  const webpackLogger = logger.child('configureWebpack');\n  const postBuildLogger = logger.child('postBuild');\n\n  const stats = {\n    scannedFileCount: 0,\n    entryCount: 0,\n    noteCount: 0,\n    resolvedCount: 0,\n    reusedPrimedFiles: false,\n    registryBytes: 0,\n  };\n\n  const shouldMeasure = (\n    log: { isLevelEnabled(level: LogLevel): boolean },\n    ...levels: LogLevel[]\n  ): boolean => levels.some((level) => log.isLevelEnabled(level));\n\n  const startTimer = (\n    log: { isLevelEnabled(level: LogLevel): boolean },\n    ...levels: LogLevel[]\n  ): number | null => (shouldMeasure(log, ...levels) ? performance.now() : null);\n\n  const endTimer = (start: number | null): number | undefined => {\n    if (start === null) return undefined;\n    return Number((performance.now() - start).toFixed(2));\n  };\n\n  const formatSiteRelativePath = (absPath: string): string => {\n    const relPath = relative(_context.siteDir, absPath);\n    const useRel = relPath && !relPath.startsWith('..') && !isAbsolute(relPath);\n    const normalized = (useRel ? relPath : absPath).replace(/\\\\/g, '/');\n    return normalized || '.';\n  };\n\n  if (\n    debugResolution.invalidLevel &&\n    typeof console !== 'undefined' &&\n    typeof console.warn === 'function'\n  ) {\n    console.warn(\n      `[${pluginName}] Ignoring DOCUSAURUS_PLUGIN_DEBUG_LEVEL=\"${debugResolution.invalidLevel}\" (expected one of: error, warn, info, debug, trace).`\n    );\n  }\n\n  if (normOpts.debug.enabled && initLogger.isLevelEnabled('info')) {\n    initLogger.info('Debug mode enabled', {\n      level: normOpts.debug.level,\n      source: debugResolution.source,\n    });\n  }\n\n  if (initLogger.isLevelEnabled('debug')) {\n    initLogger.debug('Smartlinker plugin initialized', {\n      folderCount: normOpts.folders.length,\n      iconCount: Object.keys(normOpts.icons ?? {}).length,\n    });\n  }\n\n  const resolvedFolders: ResolvedFolder[] = normOpts.folders.map((folder) => {\n    const absPath = resolve(_context.siteDir, folder.path);\n    return {\n      ...folder,\n      absPath,\n      id: normalizeFolderId(_context.siteDir, absPath),\n    } satisfies ResolvedFolder;\n  });\n\n  if (initLogger.isLevelEnabled('trace') && resolvedFolders.length > 0) {\n    initLogger.trace('Resolved SmartLink folders', () => ({\n      folders: resolvedFolders.map(\n        (folder) => `${folder.id}:${formatSiteRelativePath(folder.absPath)}`\n      ),\n    }));\n  }\n\n  const folderById = new Map<string, ResolvedFolder>();\n  for (const folder of resolvedFolders) {\n    folderById.set(folder.id, folder);\n  }\n\n  if (warnings.length > 0 && optionsLogger.isLevelEnabled('warn')) {\n    for (const warning of warnings) {\n      optionsLogger.warn(warning.message, () => ({\n        code: warning.code,\n        ...(warning.details ?? {}),\n      }));\n    }\n  }\n\n  let primedFiles: RawDocFile[] | null = null;\n\n  const collectFiles = (): RawDocFile[] => {\n    const start = startTimer(scanLogger, 'debug', 'info');\n    const files: RawDocFile[] = [];\n    for (const folder of resolvedFolders) {\n      const scanned = scanMdFiles({ roots: [folder.absPath] });\n      for (const file of scanned) {\n        files.push({ ...file, folderId: folder.id });\n      }\n    }\n    stats.scannedFileCount = files.length;\n\n    if (scanLogger.isLevelEnabled('debug')) {\n      scanLogger.debug('Scanned SmartLink folders', {\n        folderCount: resolvedFolders.length,\n        fileCount: files.length,\n        durationMs: endTimer(start),\n      });\n    }\n\n    if (scanLogger.isLevelEnabled('trace') && files.length > 0) {\n      scanLogger.trace('Collected SmartLink files', () => ({\n        files: files.map((file) => formatSiteRelativePath(file.path)),\n      }));\n    }\n\n    return files;\n  };\n\n  const applyFolderDefaults = (entries: IndexRawEntry[]) => {\n    for (const entry of entries) {\n      const folder = entry.folderId ? folderById.get(entry.folderId) : undefined;\n      if (!folder) continue;\n      if (!entry.icon && folder.defaultIcon && normOpts.icons[folder.defaultIcon]) {\n        entry.icon = folder.defaultIcon;\n      }\n    }\n  };\n\n  const computeDocIdForEntry = (entry: IndexRawEntry): string | undefined => {\n    const folder = entry.folderId ? folderById.get(entry.folderId) : undefined;\n    if (!folder) return undefined;\n    return deriveDocId(folder.absPath, entry.sourcePath);\n  };\n\n  const primeIndexProvider = () => {\n    const start = startTimer(indexLogger, 'debug', 'info');\n    primedFiles = collectFiles();\n    const { entries } = loadIndexFromFiles(primedFiles);\n    applyFolderDefaults(entries);\n    setIndexEntries(entries);\n    stats.entryCount = entries.length;\n\n    if (indexLogger.isLevelEnabled('debug')) {\n      indexLogger.debug('Primed SmartLink index provider', {\n        entryCount: entries.length,\n        durationMs: endTimer(start),\n      });\n    }\n\n    if (indexLogger.isLevelEnabled('trace') && entries.length > 0) {\n      indexLogger.trace('Primed entry identifiers', () => ({\n        entryIds: entries.map((entry) => entry.id),\n      }));\n    }\n  };\n\n  primeIndexProvider();\n\n  return {\n    name: pluginName,\n\n    configureWebpack() {\n      if (webpackLogger.isLevelEnabled('debug')) {\n        webpackLogger.debug('configureWebpack invoked', {\n          tooltipComponentCount: Object.keys(normOpts.tooltipComponents ?? {}).length,\n        });\n      }\n      return {};\n    },\n\n    async loadContent() {\n      const usingPrimed = primedFiles !== null;\n      const start = startTimer(loadLogger, 'info', 'debug');\n      const files = primedFiles ?? collectFiles();\n      primedFiles = null;\n      stats.reusedPrimedFiles = usingPrimed;\n      stats.scannedFileCount = files.length;\n\n      if (loadLogger.isLevelEnabled('debug')) {\n        loadLogger.debug('Building SmartLink artifacts', {\n          fileCount: files.length,\n          reusedPrimedFiles: usingPrimed,\n        });\n      }\n\n      if (loadLogger.isLevelEnabled('trace') && files.length > 0) {\n        loadLogger.trace('Processing SmartLink files', () => ({\n          files: files.map((file) => formatSiteRelativePath(file.path)),\n        }));\n      }\n\n      const compileMdx = await createTooltipMdxCompiler(_context);\n      const { entries, notes, registry } = await buildArtifacts(files, {\n        compileMdx,\n      });\n\n      stats.entryCount = entries.length;\n      stats.noteCount = notes.length;\n      stats.registryBytes = Buffer.byteLength(registry.contents, 'utf8');\n\n      applyFolderDefaults(entries);\n      setIndexEntries(entries);\n\n      if (loadLogger.isLevelEnabled('info')) {\n        loadLogger.info('Completed SmartLink artifact build', {\n          entryCount: entries.length,\n          noteCount: notes.length,\n          durationMs: endTimer(start),\n        });\n      }\n\n      if (loadLogger.isLevelEnabled('debug')) {\n        loadLogger.debug('Registry artifacts prepared', {\n          registryBytes: stats.registryBytes,\n        });\n      }\n\n      if (loadLogger.isLevelEnabled('trace') && entries.length > 0) {\n        loadLogger.trace('Generated SmartLink entries', () => ({\n          entryIds: entries.map((entry) => entry.id),\n          noteFiles: notes.map((note) => note.filename),\n        }));\n      }\n\n      return {\n        entries,\n        notes,\n        registry,\n        opts: normOpts,\n      } satisfies Content;\n    },\n\n    async contentLoaded({ content, actions }: { content: Content; actions: PluginContentLoadedActions }) {\n      if (!content) return;\n      const { notes, registry, entries, opts } = content;\n\n      const start = startTimer(contentLogger, 'info', 'debug');\n\n      if (contentLogger.isLevelEnabled('debug')) {\n        contentLogger.debug('Writing SmartLink generated modules', {\n          noteCount: notes.length,\n          registryModule: registry.filename,\n        });\n      }\n\n      for (const note of notes) {\n        await actions.createData(note.filename, note.contents);\n      }\n      await actions.createData(registry.filename, registry.contents);\n\n      const tooltipComponentsModule = emitTooltipComponentsModule(\n        opts.tooltipComponents ?? {}\n      );\n      await actions.createData(\n        tooltipComponentsModule.filename,\n        tooltipComponentsModule.contents\n      );\n\n      const enrichedEntries = entries.map((entry) => ({\n        ...entry,\n        docId: entry.docId ?? computeDocIdForEntry(entry),\n      }));\n\n      const docsContent = loadDocsContentFromGenerated(_context.generatedFilesDir);\n      const resolved = resolveEntryPermalinks({\n        siteDir: _context.siteDir,\n        entries: enrichedEntries,\n        docsContent,\n      });\n\n      stats.resolvedCount = resolved.length;\n\n      publishGlobalData(actions, opts, resolved);\n\n      if (contentLogger.isLevelEnabled('info')) {\n        contentLogger.info('Published SmartLink global data', {\n          entryCount: resolved.length,\n          durationMs: endTimer(start),\n        });\n      }\n\n      if (contentLogger.isLevelEnabled('trace') && resolved.length > 0) {\n        contentLogger.trace('Resolved SmartLink permalinks', () => ({\n          permalinks: resolved.map((entry) => entry.permalink ?? null),\n        }));\n      }\n    },\n\n    async postBuild() {\n      if (!postBuildLogger.isLevelEnabled('info')) {\n        return;\n      }\n      postBuildLogger.info('SmartLink build complete', {\n        entryCount: stats.resolvedCount,\n        noteCount: stats.noteCount,\n        filesScanned: stats.scannedFileCount,\n        reusedPrimedFiles: stats.reusedPrimedFiles,\n        registryBytes: stats.registryBytes,\n      });\n    },\n\n    getThemePath() {\n      return join(moduleDir, 'theme', 'runtime');\n    },\n\n    getTypeScriptThemePath() {\n      return join(moduleDir, 'theme');\n    },\n\n    getClientModules() {\n      return [join(moduleDir, 'theme/styles.css')];\n    },\n  };\n}\n\nfunction deriveDocId(folderAbsPath: string, sourcePath: string | undefined): string | undefined {\n  if (!sourcePath) return undefined;\n  const rel = relative(folderAbsPath, sourcePath);\n  if (!rel || rel.startsWith('..')) return undefined;\n  const normalized = rel.replace(/\\\\/g, '/');\n  const withoutExt = normalized.replace(/\\.[^./]+$/u, '');\n  return withoutExt || undefined;\n}\n\nfunction loadDocsContentFromGenerated(\n  generatedFilesDir: string,\n): Record<string, DocsLoadedContent | undefined> {\n  const root = join(generatedFilesDir, 'docusaurus-plugin-content-docs');\n  const result: Record<string, DocsLoadedContent> = {};\n\n  let pluginIds: string[] = [];\n  try {\n    pluginIds = readdirSync(root);\n  } catch {\n    return result;\n  }\n\n  for (const pluginId of pluginIds) {\n    const pluginDir = join(root, pluginId);\n    let stats;\n    try {\n      stats = statSync(pluginDir);\n    } catch {\n      continue;\n    }\n    if (!stats.isDirectory()) continue;\n\n    const docs: any[] = [];\n    for (const file of readdirSync(pluginDir)) {\n      if (!file.endsWith('.json')) continue;\n      if (file.startsWith('__')) continue;\n      const abs = join(pluginDir, file);\n      try {\n        const parsed = JSON.parse(readFileSync(abs, 'utf8'));\n        if (parsed && typeof parsed === 'object' && typeof parsed.permalink === 'string') {\n          docs.push(parsed);\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    result[pluginId] = {\n      loadedVersions: [\n        {\n          docs,\n        } as any,\n      ],\n    } as DocsLoadedContent;\n  }\n\n  return result;\n}\n","export interface AutoLinkEntry {\n  /** Original casing as authored in config/frontmatter */\n  literal: string;\n  /** Canonical grouping key (e.g., target id) */\n  key: string;\n}\n\nexport interface Match {\n  start: number;\n  end: number;\n  text: string;\n  key: string;\n  term: string;\n}\n\ninterface TrieNode {\n  children: Map<string, TrieNode>;\n  /** If terminal, we can store multiple variants mapping to the same canonical key; we’ll keep the longest on scan */\n  terminals?: { literal: string; key: string }[];\n}\n\nexport interface Matcher {\n  findAll(text: string): Match[];\n}\n\nfunction isWordChar(ch: string): boolean {\n  // Word = Unicode letter or number or underscore\n  // NOTE: requires /u support; Node 18+ supports Unicode property escapes.\n  // Fallback if needed: custom range checks; but we stick to \\p classes for clarity.\n  return /\\p{L}|\\p{N}|_/u.test(ch);\n}\n\nfunction buildTrie(entries: AutoLinkEntry[]): TrieNode {\n  const root: TrieNode = { children: new Map() };\n  for (const e of entries) {\n    if (!e?.literal) continue;\n    const lit = e.literal.toLocaleLowerCase();\n    if (!lit) continue;\n\n    let node = root;\n    for (const ch of Array.from(lit)) {\n      let next = node.children.get(ch);\n      if (!next) {\n        next = { children: new Map() };\n        node.children.set(ch, next);\n      }\n      node = next;\n    }\n    if (!node.terminals) node.terminals = [];\n    node.terminals.push({ literal: e.literal, key: e.key });\n  }\n  return root;\n}\n\nexport function buildMatcher(entries: AutoLinkEntry[]): Matcher {\n  // Normalize: remove duplicates by (key,literal lower)\n  const seen = new Set<string>();\n  const uniq: AutoLinkEntry[] = [];\n  for (const e of entries) {\n    if (!e || typeof e.literal !== 'string' || typeof e.key !== 'string') continue;\n    const lit = e.literal.trim();\n    const key = e.key.trim();\n    if (!lit || !key) continue;\n    const k = `${key}::${lit.toLocaleLowerCase()}`;\n    if (!seen.has(k)) {\n      seen.add(k);\n      uniq.push({ literal: lit, key });\n    }\n  }\n\n  const trie = buildTrie(uniq);\n\n  function findAll(text: string): Match[] {\n    const out: Match[] = [];\n    if (!text) return out;\n\n    const lower = text.toLocaleLowerCase();\n    const chars = Array.from(lower); // Unicode-safe indexing for scanning\n    const orig = Array.from(text);\n\n    let i = 0;\n    while (i < chars.length) {\n      let node: TrieNode | undefined = trie;\n      let j = i;\n      let bestEnd = -1;\n      let bestTerminal: { literal: string; key: string } | null = null;\n\n      while (node && j < chars.length) {\n        const ch = chars[j];\n        node = node.children.get(ch);\n        if (!node) break;\n        if (node.terminals && node.terminals.length) {\n          // Any terminal here; pick the terminal that has the longest literal by codepoints\n          // Since all terminals end at the same j, picking any is fine, but\n          // we keep the first; to be safe, prefer the longest literal to preserve original selection\n          let t = node.terminals[0];\n          for (const cand of node.terminals) {\n            if (Array.from(cand.literal).length > Array.from(t.literal).length) {\n              t = cand;\n            }\n          }\n          bestEnd = j + 1;\n          bestTerminal = t;\n        }\n        j++;\n      }\n\n      if (bestEnd !== -1 && bestTerminal) {\n        // Word boundary check around [i, bestEnd)\n        const leftOk = (i === 0) || !isWordChar(orig[i - 1] ?? '');\n        const rightOk = (bestEnd === chars.length) || !isWordChar(orig[bestEnd] ?? '');\n        if (leftOk && rightOk) {\n          const start = i;\n          const end = bestEnd;\n          const textSlice = orig.slice(start, end).join('');\n          out.push({\n            start,\n            end,\n            text: textSlice,\n            key: bestTerminal.key,\n            term: bestTerminal.literal\n          });\n          i = end; // non-overlapping\n          continue;\n        }\n      }\n\n      i += 1;\n    }\n\n    return out;\n  }\n\n  return { findAll };\n}\n\n","import type { Transformer } from 'unified';\nimport { visit, SKIP } from 'unist-util-visit';\nimport { normalize } from 'node:path';\nimport type { Parent } from 'unist';\nimport type { Content, Root, Text, PhrasingContent } from 'mdast';\nimport {\n  getIndexProvider as getRegisteredIndexProvider,\n  PLUGIN_NAME,\n  resolveDebugConfig,\n  createLogger,\n  type DebugOptions,\n  getDebugConfig,\n} from 'docusaurus-plugin-smartlinker';\nimport { buildMatcher, type AutoLinkEntry } from './matcher.js';\n\nexport interface TargetInfo {\n  id: string;\n  slug: string;\n  icon?: string;\n  sourcePath: string;\n  terms: string[];\n  folderId?: string | null;\n}\n\nexport interface IndexProvider {\n  getAllTargets(): TargetInfo[];\n  getCurrentFilePath(file: import('vfile').VFile): string;\n}\n\nexport interface RemarkSmartlinkerOptions {\n  index?: IndexProvider;\n  componentName?: string;\n  toAttr?: string;\n  iconAttr?: string;\n  tipKeyAttr?: string;\n  matchAttr?: string;\n  shortNoteComponentName?: string;\n  shortNoteTipKeyAttr?: string;\n  shortNotePlaceholder?: string;\n  restrictToFolders?: string | string[];\n  debug?: DebugOptions;\n}\n\ntype MdastNode = Content | Root;\n\nfunction isSkippable(node: MdastNode, mdxComponentNamesToSkip: Set<string>): boolean {\n  const t = (node as any).type;\n  if (t === 'code' || t === 'inlineCode') return true;\n  if (t === 'link' || t === 'linkReference') return true;\n  if (t === 'image' || t === 'imageReference') return true;\n  if (t === 'heading' && (node as any).depth <= 3) return true;\n  if (t === 'mdxJsxFlowElement' || t === 'mdxJsxTextElement') {\n    const name = (node as any).name;\n    if (typeof name === 'string' && mdxComponentNamesToSkip.has(name)) return true;\n    return false;\n  }\n  return false;\n}\n\nfunction toMdxJsxTextElement(\n  name: string,\n  attrs: Record<string, string | undefined>,\n  text?: string\n): any {\n  const attributes = Object.entries(attrs)\n    .filter(([, v]) => typeof v === 'string' && v.length > 0)\n    .map(([name, value]) => ({\n      type: 'mdxJsxAttribute',\n      name,\n      value\n    }));\n\n  const children: PhrasingContent[] = [];\n  if (typeof text === 'string' && text.length > 0) {\n    children.push({\n      type: 'text',\n      value: text\n    } as Text);\n  }\n\n  return {\n    type: 'mdxJsxTextElement',\n    name,\n    attributes,\n    children\n  };\n}\n\nfunction normalizeFolderKey(value: string): string {\n  const trimmed = value.trim();\n  const withoutBackslashes = trimmed.replace(/\\\\/g, '/');\n  const withoutTrailing = withoutBackslashes.replace(/\\/+$/, '');\n  return withoutTrailing || '.';\n}\n\nexport default function remarkSmartlinker(opts?: RemarkSmartlinkerOptions): Transformer {\n  const options = opts ?? {};\n\n  // Resolve debug config: prefer explicit option, else plugin's shared config, then env\n  const sharedDebug = typeof getDebugConfig === 'function' ? getDebugConfig() : undefined;\n  const debugInput = options.debug ?? sharedDebug;\n  const debugResolution = resolveDebugConfig(debugInput);\n  const baseLogger = createLogger({ pluginName: PLUGIN_NAME, debug: debugResolution.config });\n  const initLogger = baseLogger.child('remark:init');\n  const prepareLogger = baseLogger.child('remark:prepare');\n  const transformLogger = baseLogger.child('remark:transform');\n\n  if (debugResolution.invalidLevel && typeof console !== 'undefined' && typeof console.warn === 'function') {\n    console.warn(\n      `[${PLUGIN_NAME}] Ignoring DOCUSAURUS_PLUGIN_DEBUG_LEVEL=\"${debugResolution.invalidLevel}\" (expected one of: error, warn, info, debug, trace).`\n    );\n  }\n\n  const componentName = options.componentName ?? 'SmartLink';\n  const toAttr = options.toAttr ?? 'to';\n  const iconAttr = options.iconAttr ?? 'icon';\n  const tipKeyAttr = options.tipKeyAttr ?? 'tipKey';\n  const matchAttr = options.matchAttr ?? 'match';\n  const shortNoteComponentName = options.shortNoteComponentName ?? 'LinkifyShortNote';\n  const shortNoteTipKeyAttr = options.shortNoteTipKeyAttr ?? tipKeyAttr;\n  const shortNotePlaceholder = options.shortNotePlaceholder ?? '%%SHORT_NOTICE%%';\n  const restrictInput = options.restrictToFolders;\n  const restrictArray = Array.isArray(restrictInput)\n    ? restrictInput\n    : restrictInput\n    ? [restrictInput]\n    : [];\n  const folderFilter = new Set(\n    restrictArray\n      .map((value) => (typeof value === 'string' ? normalizeFolderKey(value) : null))\n      .filter((value): value is string => !!value)\n  );\n  type PreparedIndex = {\n    targets: TargetInfo[];\n    matcher: ReturnType<typeof buildMatcher>;\n    claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n    targetByPath: Map<string, TargetInfo>;\n    targetById: Map<string, TargetInfo>;\n    targetBySlug: Map<string, TargetInfo>;\n  };\n\n  const mdxComponentNamesToSkip = new Set<string>([\n    componentName,\n    shortNoteComponentName,\n  ]);\n\n  if (initLogger.isLevelEnabled('debug')) {\n    initLogger.debug('Remark transformer initialized', () => ({\n      componentName,\n      shortNoteComponentName,\n      restrictFilterCount: folderFilter.size,\n      debugLevel: debugResolution.config.level,\n      debugEnabled: debugResolution.config.enabled,\n    }));\n  }\n\n  let cachedProvider: IndexProvider | undefined;\n  let cachedFilterSignature = '';\n  let prepared: PreparedIndex | undefined;\n\n  function ensurePreparedIndex(): { index: IndexProvider } & PreparedIndex {\n    const provider = options.index ?? getRegisteredIndexProvider();\n\n    if (!provider) {\n      throw new Error(\n        '[docusaurus-plugin-smartlinker] No index provider configured. Pass `{ index }` explicitly or make sure the Docusaurus plugin runs before this remark transformer.'\n      );\n    }\n\n    const filterSignature = folderFilter.size\n      ? Array.from(folderFilter).sort().join('|')\n      : 'ALL';\n\n    if (provider !== cachedProvider || filterSignature !== cachedFilterSignature) {\n      const allTargets = provider.getAllTargets();\n      const targets = folderFilter.size\n        ? allTargets.filter((target) => {\n            const id = typeof target.folderId === 'string' ? normalizeFolderKey(target.folderId) : null;\n            if (!id) return false;\n            return folderFilter.has(id);\n          })\n        : allTargets;\n\n      const termEntries: AutoLinkEntry[] = [];\n      const claimMap = new Map<string, { id: string; slug: string; icon?: string }[]>();\n\n      for (const t of targets) {\n        for (const lit of t.terms) {\n          const literal = String(lit ?? '').trim();\n          if (!literal) continue;\n          termEntries.push({ literal, key: `${t.id}::${t.slug}::${t.icon ?? ''}` });\n\n          const ll = literal.toLocaleLowerCase();\n          const arr = claimMap.get(ll) ?? [];\n          arr.push({ id: t.id, slug: t.slug, icon: t.icon });\n          claimMap.set(ll, arr);\n        }\n      }\n\n      termEntries.sort((a, b) => b.literal.length - a.literal.length);\n      for (const [, arr] of claimMap) arr.sort((a, b) => a.id.localeCompare(b.id));\n\n      const matcher = buildMatcher(termEntries);\n\n      const targetByPath = new Map<string, TargetInfo>();\n      const targetById = new Map<string, TargetInfo>();\n      const targetBySlug = new Map<string, TargetInfo>();\n\n      for (const t of targets) {\n        if (t.sourcePath) {\n          const key = normalizePath(t.sourcePath);\n          if (key) targetByPath.set(key, t);\n        }\n        if (t.id) targetById.set(t.id, t);\n        if (t.slug) targetBySlug.set(t.slug, t);\n      }\n\n      prepared = { targets, matcher, claimMap, targetByPath, targetById, targetBySlug };\n      cachedProvider = provider;\n      cachedFilterSignature = filterSignature;\n\n      if (prepareLogger.isLevelEnabled('debug')) {\n        prepareLogger.debug('Prepared SmartLink term matcher', {\n          targetCount: targets.length,\n          termCount: termEntries.length,\n          filteredByFolders: folderFilter.size > 0,\n        });\n      }\n\n      if (prepareLogger.isLevelEnabled('trace')) {\n        const folders = Array.from(folderFilter.values());\n        if (folders.length > 0) {\n          prepareLogger.trace('Active folder filters', () => ({ folders }));\n        }\n      }\n    }\n\n    return { index: provider, ...(prepared as PreparedIndex) };\n  }\n\n  return (tree: any, file: any) => {\n    const { index, matcher, claimMap, targetByPath, targetById, targetBySlug } = ensurePreparedIndex();\n\n    const currentTarget = findCurrentTarget({\n      file,\n      index,\n      targetByPath,\n      targetById,\n      targetBySlug,\n    });\n\n    const filePath = typeof file?.path === 'string' ? file.path : undefined;\n    if (transformLogger.isLevelEnabled('info')) {\n      transformLogger.info('Processing file', () => ({\n        filePath: filePath ?? null,\n        currentTargetId: currentTarget?.id ?? null,\n        currentTargetSlug: currentTarget?.slug ?? null,\n      }));\n    }\n\n    const onLinkInserted = (args: { text: string; slug: string; id: string; icon?: string }) => {\n      if (!transformLogger.isLevelEnabled('debug')) return;\n      transformLogger.debug('Smartlink inserted', () => ({\n        filePath: filePath ?? null,\n        text: args.text,\n        to: args.slug,\n        tipKey: args.id,\n        icon: args.icon ?? null,\n      }));\n    };\n    const onShortNoteInserted = (args: { id: string }) => {\n      if (!transformLogger.isLevelEnabled('debug')) return;\n      transformLogger.debug('Short-note placeholder replaced', () => ({\n        filePath: filePath ?? null,\n        tipKey: args.id,\n      }));\n    };\n\n    visit(tree, (node, _index, parent: Parent | undefined) => {\n      if (isSkippable(node as any, mdxComponentNamesToSkip)) return SKIP as any;\n      if (!parent) return;\n      if ((node as any).type !== 'text') return;\n\n      const textNode = node as Text;\n      const text = textNode.value ?? '';\n      if (!text || !text.trim()) return;\n\n      const result = transformText({\n        text,\n        matcher,\n        claimMap,\n        componentName,\n        toAttr,\n        tipKeyAttr,\n        matchAttr,\n        iconAttr,\n        shortNoteComponentName,\n        shortNoteTipKeyAttr,\n        shortNotePlaceholder,\n        currentTarget,\n        onLinkInserted,\n        onShortNoteInserted,\n      });\n      if (!result || !result.changed) return;\n\n      const idx = (parent.children as Content[]).indexOf(node as any);\n      if (idx >= 0) (parent.children as Content[]).splice(idx, 1, ...result.nodes);\n\n    });\n\n    // No extra summary logs to avoid noise; per-insertion debug logs above\n\n    return tree;\n  };\n}\n\nfunction normalizePath(value: string | null | undefined): string | null {\n  if (!value || typeof value !== 'string') return null;\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  try {\n    return normalize(trimmed).replace(/\\\\/g, '/').toLowerCase();\n  } catch {\n    return trimmed.replace(/\\\\/g, '/').toLowerCase();\n  }\n}\n\ninterface TransformArgs {\n  text: string;\n  matcher: ReturnType<typeof buildMatcher>;\n  claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n  componentName: string;\n  toAttr: string;\n  tipKeyAttr: string;\n  matchAttr: string;\n  iconAttr: string;\n  shortNoteComponentName: string;\n  shortNoteTipKeyAttr: string;\n  shortNotePlaceholder: string;\n  currentTarget?: TargetInfo;\n  onLinkInserted?: (args: { text: string; slug: string; id: string; icon?: string }) => void;\n  onShortNoteInserted?: (args: { id: string }) => void;\n}\n\ntype TransformResult = { nodes: PhrasingContent[]; changed: boolean } | null;\n\nfunction transformText(args: TransformArgs): TransformResult {\n  const {\n    text,\n    matcher,\n    claimMap,\n    componentName,\n    toAttr,\n    tipKeyAttr,\n    matchAttr,\n    iconAttr,\n    shortNoteComponentName,\n    shortNoteTipKeyAttr,\n    shortNotePlaceholder,\n    currentTarget,\n    onLinkInserted,\n    onShortNoteInserted,\n  } = args;\n\n  const placeholder = shortNotePlaceholder;\n  const hasPlaceholder = placeholder && placeholder.length > 0 && text.includes(placeholder);\n\n  if (hasPlaceholder && currentTarget) {\n    const segments = text.split(placeholder);\n    const nodes: PhrasingContent[] = [];\n    let changed = false;\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (segment) {\n        const segRes = transformSegment({\n          text: segment,\n          matcher,\n          claimMap,\n          componentName,\n          toAttr,\n          tipKeyAttr,\n          matchAttr,\n          iconAttr,\n          currentTarget,\n        });\n        nodes.push(...segRes.nodes);\n        if (segRes.changed) changed = true;\n      }\n\n      if (i < segments.length - 1) {\n        nodes.push(\n          toMdxJsxTextElement(\n            shortNoteComponentName,\n            { [shortNoteTipKeyAttr]: currentTarget.id },\n            undefined\n          ) as any\n        );\n        if (onShortNoteInserted) onShortNoteInserted({ id: currentTarget.id });\n        changed = true;\n      }\n    }\n\n    return { nodes, changed };\n  }\n\n  if (hasPlaceholder) {\n    // Placeholder present but no current target – leave text untouched.\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  return transformSegment({\n    text,\n    matcher,\n    claimMap,\n    componentName,\n    toAttr,\n    tipKeyAttr,\n    matchAttr,\n    iconAttr,\n    currentTarget,\n    onLinkInserted,\n  });\n}\n\ninterface TransformSegmentArgs {\n  text: string;\n  matcher: ReturnType<typeof buildMatcher>;\n  claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n  componentName: string;\n  toAttr: string;\n  tipKeyAttr: string;\n  matchAttr: string;\n  iconAttr: string;\n  currentTarget?: TargetInfo;\n  onLinkInserted?: (args: { text: string; slug: string; id: string; icon?: string }) => void;\n}\n\nfunction transformSegment(args: TransformSegmentArgs): { nodes: PhrasingContent[]; changed: boolean } {\n  const { text, matcher, claimMap, componentName, toAttr, tipKeyAttr, matchAttr, iconAttr, currentTarget, onLinkInserted } = args;\n\n  if (!text) return { nodes: [], changed: false };\n\n  const matches = matcher.findAll(text);\n  if (!matches.length) {\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  const newChildren: PhrasingContent[] = [];\n  let cursor = 0;\n  let anyLinkInserted = false;\n\n  for (const m of matches) {\n    const start = m.start;\n    const end = m.end;\n    if (start > cursor) newChildren.push({ type: 'text', value: text.slice(cursor, start) } as Text);\n\n    let id = '';\n    let slug = '';\n    let icon: string | undefined = undefined;\n    {\n      const parts = m.key.split('::');\n      id = parts[0] ?? '';\n      slug = parts[1] ?? '';\n      icon = parts[2] || undefined;\n      const claimers = claimMap.get(m.term.toLocaleLowerCase());\n      if (claimers && claimers.length > 1) {\n        const chosen = claimers[0];\n        id = chosen.id;\n        slug = chosen.slug;\n        icon = chosen.icon;\n      }\n    }\n\n    if (currentTarget && id && currentTarget.id === id) {\n      newChildren.push({ type: 'text', value: text.slice(start, end) } as Text);\n    } else {\n      const element = toMdxJsxTextElement(\n        componentName,\n        { [toAttr]: slug, [tipKeyAttr]: id, [matchAttr]: m.text, [iconAttr]: icon },\n        m.text\n      );\n      newChildren.push(element as any);\n      anyLinkInserted = true;\n      if (onLinkInserted) onLinkInserted({ text: m.text, slug, id, icon });\n    }\n\n    cursor = end;\n  }\n\n  if (cursor < text.length) newChildren.push({ type: 'text', value: text.slice(cursor) } as Text);\n\n  if (!anyLinkInserted) {\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  return { nodes: newChildren, changed: true };\n}\n\ninterface FindCurrentTargetArgs {\n  file: any;\n  index: IndexProvider;\n  targetByPath: Map<string, TargetInfo>;\n  targetById: Map<string, TargetInfo>;\n  targetBySlug: Map<string, TargetInfo>;\n}\n\nfunction findCurrentTarget(args: FindCurrentTargetArgs): TargetInfo | undefined {\n  const { file, index, targetByPath, targetById, targetBySlug } = args;\n\n  const pathCandidates = new Set<string>();\n  const viaIndex = index.getCurrentFilePath(file as any);\n  if (typeof viaIndex === 'string') pathCandidates.add(viaIndex);\n  if (typeof file?.path === 'string') pathCandidates.add(file.path);\n  if (Array.isArray(file?.history)) {\n    for (const entry of file.history) {\n      if (typeof entry === 'string') pathCandidates.add(entry);\n    }\n  }\n\n  for (const candidate of pathCandidates) {\n    const key = normalizePath(candidate);\n    if (!key) continue;\n    const direct = targetByPath.get(key);\n    if (direct) return direct;\n    for (const [pathKey, target] of targetByPath) {\n      if (pathKey.endsWith(key) || key.endsWith(pathKey)) {\n        return target;\n      }\n    }\n  }\n\n  const data = file?.data ?? {};\n  const idCandidates = new Set<string>();\n  const slugCandidates = new Set<string>();\n\n  const pushId = (value: unknown) => {\n    if (typeof value === 'string' && value.trim()) idCandidates.add(value.trim());\n  };\n  const pushSlug = (value: unknown) => {\n    if (typeof value === 'string' && value.trim()) slugCandidates.add(value.trim());\n  };\n\n  pushId((data as any).id);\n  pushId((data as any).docId);\n  pushId((data as any).unversionedId);\n  pushSlug((data as any).slug);\n  pushSlug((data as any).permalink);\n\n  const frontMatter = (data as any).frontMatter ?? {};\n  pushId(frontMatter?.id);\n  pushSlug(frontMatter?.slug);\n  pushSlug(frontMatter?.permalink);\n\n  for (const id of idCandidates) {\n    const target = targetById.get(id);\n    if (target) return target;\n  }\n\n  for (const slug of slugCandidates) {\n    const target = targetBySlug.get(slug);\n    if (target) return target;\n  }\n\n  return undefined;\n}\n","import type { Transformer } from 'unified';\nimport type { VFile } from 'vfile';\nimport type { DebugOptions } from '../options.js';\nimport remarkSmartlinkerImpl from '../../../remark-smartlinker/src/transform.js';\nimport { buildMatcher as buildMatcherImpl } from '../../../remark-smartlinker/src/matcher.js';\n\nexport interface TargetInfo {\n  id: string;\n  slug: string;\n  icon?: string;\n  sourcePath: string;\n  terms: string[];\n  folderId?: string | null;\n}\n\nexport interface IndexProvider {\n  getAllTargets(): TargetInfo[];\n  getCurrentFilePath(file: VFile): string;\n}\n\nexport interface RemarkSmartlinkerOptions {\n  index?: IndexProvider;\n  componentName?: string;\n  toAttr?: string;\n  iconAttr?: string;\n  tipKeyAttr?: string;\n  matchAttr?: string;\n  shortNoteComponentName?: string;\n  shortNoteTipKeyAttr?: string;\n  shortNotePlaceholder?: string;\n  restrictToFolders?: string | string[];\n  debug?: DebugOptions;\n}\n\nexport interface AutoLinkEntry {\n  /** Original casing as authored in config/frontmatter */\n  literal: string;\n  /** Canonical grouping key (e.g., target id) */\n  key: string;\n}\n\nexport interface Match {\n  start: number;\n  end: number;\n  text: string;\n  key: string;\n  term: string;\n}\n\nexport interface Matcher {\n  findAll(text: string): Match[];\n}\n\nexport function buildMatcher(entries: AutoLinkEntry[]): Matcher {\n  return buildMatcherImpl(entries) as Matcher;\n}\n\nexport default function remarkSmartlinker(opts?: RemarkSmartlinkerOptions): Transformer {\n  return (remarkSmartlinkerImpl as (options?: RemarkSmartlinkerOptions) => Transformer)(opts);\n}\n"]}