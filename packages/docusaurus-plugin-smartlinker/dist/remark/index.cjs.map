{"version":3,"sources":["../../../remark-smartlinker/src/matcher.ts","../../../remark-smartlinker/src/transform.ts","../../../remark-smartlinker/src/index.ts","../../src/remark/index.ts"],"names":["name","getDebugConfig","resolveDebugConfig","createLogger","PLUGIN_NAME","getRegisteredIndexProvider","visit","SKIP","normalize"],"mappings":"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","file":"index.cjs","sourcesContent":["export interface AutoLinkEntry {\n  /** Original casing as authored in config/frontmatter */\n  literal: string;\n  /** Canonical grouping key (e.g., target id) */\n  key: string;\n}\n\nexport interface Match {\n  start: number;\n  end: number;\n  text: string;\n  key: string;\n  term: string;\n}\n\ninterface TrieNode {\n  children: Map<string, TrieNode>;\n  /** If terminal, we can store multiple variants mapping to the same canonical key; we’ll keep the longest on scan */\n  terminals?: { literal: string; key: string }[];\n}\n\nexport interface Matcher {\n  findAll(text: string): Match[];\n}\n\nfunction isWordChar(ch: string): boolean {\n  // Word = Unicode letter or number or underscore\n  // NOTE: requires /u support; Node 18+ supports Unicode property escapes.\n  // Fallback if needed: custom range checks; but we stick to \\p classes for clarity.\n  return /\\p{L}|\\p{N}|_/u.test(ch);\n}\n\nfunction buildTrie(entries: AutoLinkEntry[]): TrieNode {\n  const root: TrieNode = { children: new Map() };\n  for (const e of entries) {\n    if (!e?.literal) continue;\n    const lit = e.literal.toLocaleLowerCase();\n    if (!lit) continue;\n\n    let node = root;\n    for (const ch of Array.from(lit)) {\n      let next = node.children.get(ch);\n      if (!next) {\n        next = { children: new Map() };\n        node.children.set(ch, next);\n      }\n      node = next;\n    }\n    if (!node.terminals) node.terminals = [];\n    node.terminals.push({ literal: e.literal, key: e.key });\n  }\n  return root;\n}\n\nexport function buildMatcher(entries: AutoLinkEntry[]): Matcher {\n  // Normalize: remove duplicates by (key,literal lower)\n  const seen = new Set<string>();\n  const uniq: AutoLinkEntry[] = [];\n  for (const e of entries) {\n    if (!e || typeof e.literal !== 'string' || typeof e.key !== 'string') continue;\n    const lit = e.literal.trim();\n    const key = e.key.trim();\n    if (!lit || !key) continue;\n    const k = `${key}::${lit.toLocaleLowerCase()}`;\n    if (!seen.has(k)) {\n      seen.add(k);\n      uniq.push({ literal: lit, key });\n    }\n  }\n\n  const trie = buildTrie(uniq);\n\n  function findAll(text: string): Match[] {\n    const out: Match[] = [];\n    if (!text) return out;\n\n    const lower = text.toLocaleLowerCase();\n    const chars = Array.from(lower); // Unicode-safe indexing for scanning\n    const orig = Array.from(text);\n\n    let i = 0;\n    while (i < chars.length) {\n      let node: TrieNode | undefined = trie;\n      let j = i;\n      let bestEnd = -1;\n      let bestTerminal: { literal: string; key: string } | null = null;\n\n      while (node && j < chars.length) {\n        const ch = chars[j];\n        node = node.children.get(ch);\n        if (!node) break;\n        if (node.terminals && node.terminals.length) {\n          // Any terminal here; pick the terminal that has the longest literal by codepoints\n          // Since all terminals end at the same j, picking any is fine, but\n          // we keep the first; to be safe, prefer the longest literal to preserve original selection\n          let t = node.terminals[0];\n          for (const cand of node.terminals) {\n            if (Array.from(cand.literal).length > Array.from(t.literal).length) {\n              t = cand;\n            }\n          }\n          bestEnd = j + 1;\n          bestTerminal = t;\n        }\n        j++;\n      }\n\n      if (bestEnd !== -1 && bestTerminal) {\n        // Word boundary check around [i, bestEnd)\n        const leftOk = (i === 0) || !isWordChar(orig[i - 1] ?? '');\n        const rightOk = (bestEnd === chars.length) || !isWordChar(orig[bestEnd] ?? '');\n        if (leftOk && rightOk) {\n          const start = i;\n          const end = bestEnd;\n          const textSlice = orig.slice(start, end).join('');\n          out.push({\n            start,\n            end,\n            text: textSlice,\n            key: bestTerminal.key,\n            term: bestTerminal.literal\n          });\n          i = end; // non-overlapping\n          continue;\n        }\n      }\n\n      i += 1;\n    }\n\n    return out;\n  }\n\n  return { findAll };\n}\n\n","import type { Transformer } from 'unified';\nimport { visit, SKIP } from 'unist-util-visit';\nimport { normalize } from 'node:path';\nimport type { Parent } from 'unist';\nimport type { Content, Root, Text, PhrasingContent } from 'mdast';\nimport {\n  getIndexProvider as getRegisteredIndexProvider,\n  PLUGIN_NAME,\n  resolveDebugConfig,\n  createLogger,\n  type DebugOptions,\n  getDebugConfig,\n} from 'docusaurus-plugin-smartlinker';\nimport { buildMatcher, type AutoLinkEntry } from './matcher.js';\n\nexport interface TargetInfo {\n  id: string;\n  slug: string;\n  icon?: string;\n  sourcePath: string;\n  terms: string[];\n  folderId?: string | null;\n}\n\nexport interface IndexProvider {\n  getAllTargets(): TargetInfo[];\n  getCurrentFilePath(file: import('vfile').VFile): string;\n}\n\nexport interface RemarkSmartlinkerOptions {\n  index?: IndexProvider;\n  componentName?: string;\n  toAttr?: string;\n  iconAttr?: string;\n  tipKeyAttr?: string;\n  matchAttr?: string;\n  shortNoteComponentName?: string;\n  shortNoteTipKeyAttr?: string;\n  shortNotePlaceholder?: string;\n  restrictToFolders?: string | string[];\n  debug?: DebugOptions;\n}\n\ntype MdastNode = Content | Root;\n\nfunction isSkippable(node: MdastNode, mdxComponentNamesToSkip: Set<string>): boolean {\n  const t = (node as any).type;\n  if (t === 'code' || t === 'inlineCode') return true;\n  if (t === 'link' || t === 'linkReference') return true;\n  if (t === 'image' || t === 'imageReference') return true;\n  if (t === 'heading' && (node as any).depth <= 3) return true;\n  if (t === 'mdxJsxFlowElement' || t === 'mdxJsxTextElement') {\n    const name = (node as any).name;\n    if (typeof name === 'string' && mdxComponentNamesToSkip.has(name)) return true;\n    return false;\n  }\n  return false;\n}\n\nfunction toMdxJsxTextElement(\n  name: string,\n  attrs: Record<string, string | undefined>,\n  text?: string\n): any {\n  const attributes = Object.entries(attrs)\n    .filter(([, v]) => typeof v === 'string' && v.length > 0)\n    .map(([name, value]) => ({\n      type: 'mdxJsxAttribute',\n      name,\n      value\n    }));\n\n  const children: PhrasingContent[] = [];\n  if (typeof text === 'string' && text.length > 0) {\n    children.push({\n      type: 'text',\n      value: text\n    } as Text);\n  }\n\n  return {\n    type: 'mdxJsxTextElement',\n    name,\n    attributes,\n    children\n  };\n}\n\nfunction normalizeFolderKey(value: string): string {\n  const trimmed = value.trim();\n  const withoutBackslashes = trimmed.replace(/\\\\/g, '/');\n  const withoutTrailing = withoutBackslashes.replace(/\\/+$/, '');\n  return withoutTrailing || '.';\n}\n\nexport default function remarkSmartlinker(opts?: RemarkSmartlinkerOptions): Transformer {\n  const options = opts ?? {};\n\n  // Resolve debug config: prefer explicit option, else plugin's shared config, then env\n  const sharedDebug = typeof getDebugConfig === 'function' ? getDebugConfig() : undefined;\n  const debugInput = options.debug ?? sharedDebug;\n  const debugResolution = resolveDebugConfig(debugInput);\n  const baseLogger = createLogger({ pluginName: PLUGIN_NAME, debug: debugResolution.config });\n  const initLogger = baseLogger.child('remark:init');\n  const prepareLogger = baseLogger.child('remark:prepare');\n  const transformLogger = baseLogger.child('remark:transform');\n\n  if (debugResolution.invalidLevel && typeof console !== 'undefined' && typeof console.warn === 'function') {\n    console.warn(\n      `[${PLUGIN_NAME}] Ignoring DOCUSAURUS_PLUGIN_DEBUG_LEVEL=\"${debugResolution.invalidLevel}\" (expected one of: error, warn, info, debug, trace).`\n    );\n  }\n\n  const componentName = options.componentName ?? 'SmartLink';\n  const toAttr = options.toAttr ?? 'to';\n  const iconAttr = options.iconAttr ?? 'icon';\n  const tipKeyAttr = options.tipKeyAttr ?? 'tipKey';\n  const matchAttr = options.matchAttr ?? 'match';\n  const shortNoteComponentName = options.shortNoteComponentName ?? 'LinkifyShortNote';\n  const shortNoteTipKeyAttr = options.shortNoteTipKeyAttr ?? tipKeyAttr;\n  const shortNotePlaceholder = options.shortNotePlaceholder ?? '%%SHORT_NOTICE%%';\n  const restrictInput = options.restrictToFolders;\n  const restrictArray = Array.isArray(restrictInput)\n    ? restrictInput\n    : restrictInput\n    ? [restrictInput]\n    : [];\n  const folderFilter = new Set(\n    restrictArray\n      .map((value) => (typeof value === 'string' ? normalizeFolderKey(value) : null))\n      .filter((value): value is string => !!value)\n  );\n  type PreparedIndex = {\n    targets: TargetInfo[];\n    matcher: ReturnType<typeof buildMatcher>;\n    claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n    targetByPath: Map<string, TargetInfo>;\n    targetById: Map<string, TargetInfo>;\n    targetBySlug: Map<string, TargetInfo>;\n  };\n\n  const mdxComponentNamesToSkip = new Set<string>([\n    componentName,\n    shortNoteComponentName,\n  ]);\n\n  if (initLogger.isLevelEnabled('debug')) {\n    initLogger.debug('Remark transformer initialized', () => ({\n      componentName,\n      shortNoteComponentName,\n      restrictFilterCount: folderFilter.size,\n      debugLevel: debugResolution.config.level,\n      debugEnabled: debugResolution.config.enabled,\n    }));\n  }\n\n  let cachedProvider: IndexProvider | undefined;\n  let cachedFilterSignature = '';\n  let prepared: PreparedIndex | undefined;\n\n  function ensurePreparedIndex(): { index: IndexProvider } & PreparedIndex {\n    const provider = options.index ?? getRegisteredIndexProvider();\n\n    if (!provider) {\n      throw new Error(\n        '[docusaurus-plugin-smartlinker] No index provider configured. Pass `{ index }` explicitly or make sure the Docusaurus plugin runs before this remark transformer.'\n      );\n    }\n\n    const filterSignature = folderFilter.size\n      ? Array.from(folderFilter).sort().join('|')\n      : 'ALL';\n\n    if (provider !== cachedProvider || filterSignature !== cachedFilterSignature) {\n      const allTargets = provider.getAllTargets();\n      const targets = folderFilter.size\n        ? allTargets.filter((target) => {\n            const id = typeof target.folderId === 'string' ? normalizeFolderKey(target.folderId) : null;\n            if (!id) return false;\n            return folderFilter.has(id);\n          })\n        : allTargets;\n\n      const termEntries: AutoLinkEntry[] = [];\n      const claimMap = new Map<string, { id: string; slug: string; icon?: string }[]>();\n\n      for (const t of targets) {\n        for (const lit of t.terms) {\n          const literal = String(lit ?? '').trim();\n          if (!literal) continue;\n          termEntries.push({ literal, key: `${t.id}::${t.slug}::${t.icon ?? ''}` });\n\n          const ll = literal.toLocaleLowerCase();\n          const arr = claimMap.get(ll) ?? [];\n          arr.push({ id: t.id, slug: t.slug, icon: t.icon });\n          claimMap.set(ll, arr);\n        }\n      }\n\n      termEntries.sort((a, b) => b.literal.length - a.literal.length);\n      for (const [, arr] of claimMap) arr.sort((a, b) => a.id.localeCompare(b.id));\n\n      const matcher = buildMatcher(termEntries);\n\n      const targetByPath = new Map<string, TargetInfo>();\n      const targetById = new Map<string, TargetInfo>();\n      const targetBySlug = new Map<string, TargetInfo>();\n\n      for (const t of targets) {\n        if (t.sourcePath) {\n          const key = normalizePath(t.sourcePath);\n          if (key) targetByPath.set(key, t);\n        }\n        if (t.id) targetById.set(t.id, t);\n        if (t.slug) targetBySlug.set(t.slug, t);\n      }\n\n      prepared = { targets, matcher, claimMap, targetByPath, targetById, targetBySlug };\n      cachedProvider = provider;\n      cachedFilterSignature = filterSignature;\n\n      if (prepareLogger.isLevelEnabled('debug')) {\n        prepareLogger.debug('Prepared SmartLink term matcher', {\n          targetCount: targets.length,\n          termCount: termEntries.length,\n          filteredByFolders: folderFilter.size > 0,\n        });\n      }\n\n      if (prepareLogger.isLevelEnabled('trace')) {\n        const folders = Array.from(folderFilter.values());\n        if (folders.length > 0) {\n          prepareLogger.trace('Active folder filters', () => ({ folders }));\n        }\n      }\n    }\n\n    return { index: provider, ...(prepared as PreparedIndex) };\n  }\n\n  return (tree: any, file: any) => {\n    const { index, matcher, claimMap, targetByPath, targetById, targetBySlug } = ensurePreparedIndex();\n\n    const currentTarget = findCurrentTarget({\n      file,\n      index,\n      targetByPath,\n      targetById,\n      targetBySlug,\n    });\n\n    const filePath = typeof file?.path === 'string' ? file.path : undefined;\n    if (transformLogger.isLevelEnabled('info')) {\n      transformLogger.info('Processing file', () => ({\n        filePath: filePath ?? null,\n        currentTargetId: currentTarget?.id ?? null,\n        currentTargetSlug: currentTarget?.slug ?? null,\n      }));\n    }\n\n    const onLinkInserted = (args: { text: string; slug: string; id: string; icon?: string }) => {\n      if (!transformLogger.isLevelEnabled('debug')) return;\n      transformLogger.debug('Smartlink inserted', () => ({\n        filePath: filePath ?? null,\n        text: args.text,\n        to: args.slug,\n        tipKey: args.id,\n        icon: args.icon ?? null,\n      }));\n    };\n    const onShortNoteInserted = (args: { id: string }) => {\n      if (!transformLogger.isLevelEnabled('debug')) return;\n      transformLogger.debug('Short-note placeholder replaced', () => ({\n        filePath: filePath ?? null,\n        tipKey: args.id,\n      }));\n    };\n\n    visit(tree, (node, _index, parent: Parent | undefined) => {\n      if (isSkippable(node as any, mdxComponentNamesToSkip)) return SKIP as any;\n      if (!parent) return;\n      if ((node as any).type !== 'text') return;\n\n      const textNode = node as Text;\n      const text = textNode.value ?? '';\n      if (!text || !text.trim()) return;\n\n      const result = transformText({\n        text,\n        matcher,\n        claimMap,\n        componentName,\n        toAttr,\n        tipKeyAttr,\n        matchAttr,\n        iconAttr,\n        shortNoteComponentName,\n        shortNoteTipKeyAttr,\n        shortNotePlaceholder,\n        currentTarget,\n        onLinkInserted,\n        onShortNoteInserted,\n      });\n      if (!result || !result.changed) return;\n\n      const idx = (parent.children as Content[]).indexOf(node as any);\n      if (idx >= 0) (parent.children as Content[]).splice(idx, 1, ...result.nodes);\n\n    });\n\n    // No extra summary logs to avoid noise; per-insertion debug logs above\n\n    return tree;\n  };\n}\n\nfunction normalizePath(value: string | null | undefined): string | null {\n  if (!value || typeof value !== 'string') return null;\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  try {\n    return normalize(trimmed).replace(/\\\\/g, '/').toLowerCase();\n  } catch {\n    return trimmed.replace(/\\\\/g, '/').toLowerCase();\n  }\n}\n\ninterface TransformArgs {\n  text: string;\n  matcher: ReturnType<typeof buildMatcher>;\n  claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n  componentName: string;\n  toAttr: string;\n  tipKeyAttr: string;\n  matchAttr: string;\n  iconAttr: string;\n  shortNoteComponentName: string;\n  shortNoteTipKeyAttr: string;\n  shortNotePlaceholder: string;\n  currentTarget?: TargetInfo;\n  onLinkInserted?: (args: { text: string; slug: string; id: string; icon?: string }) => void;\n  onShortNoteInserted?: (args: { id: string }) => void;\n}\n\ntype TransformResult = { nodes: PhrasingContent[]; changed: boolean } | null;\n\nfunction transformText(args: TransformArgs): TransformResult {\n  const {\n    text,\n    matcher,\n    claimMap,\n    componentName,\n    toAttr,\n    tipKeyAttr,\n    matchAttr,\n    iconAttr,\n    shortNoteComponentName,\n    shortNoteTipKeyAttr,\n    shortNotePlaceholder,\n    currentTarget,\n    onLinkInserted,\n    onShortNoteInserted,\n  } = args;\n\n  const placeholder = shortNotePlaceholder;\n  const hasPlaceholder = placeholder && placeholder.length > 0 && text.includes(placeholder);\n\n  if (hasPlaceholder && currentTarget) {\n    const segments = text.split(placeholder);\n    const nodes: PhrasingContent[] = [];\n    let changed = false;\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (segment) {\n        const segRes = transformSegment({\n          text: segment,\n          matcher,\n          claimMap,\n          componentName,\n          toAttr,\n          tipKeyAttr,\n          matchAttr,\n          iconAttr,\n          currentTarget,\n        });\n        nodes.push(...segRes.nodes);\n        if (segRes.changed) changed = true;\n      }\n\n      if (i < segments.length - 1) {\n        nodes.push(\n          toMdxJsxTextElement(\n            shortNoteComponentName,\n            { [shortNoteTipKeyAttr]: currentTarget.id },\n            undefined\n          ) as any\n        );\n        if (onShortNoteInserted) onShortNoteInserted({ id: currentTarget.id });\n        changed = true;\n      }\n    }\n\n    return { nodes, changed };\n  }\n\n  if (hasPlaceholder) {\n    // Placeholder present but no current target – leave text untouched.\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  return transformSegment({\n    text,\n    matcher,\n    claimMap,\n    componentName,\n    toAttr,\n    tipKeyAttr,\n    matchAttr,\n    iconAttr,\n    currentTarget,\n    onLinkInserted,\n  });\n}\n\ninterface TransformSegmentArgs {\n  text: string;\n  matcher: ReturnType<typeof buildMatcher>;\n  claimMap: Map<string, { id: string; slug: string; icon?: string }[]>;\n  componentName: string;\n  toAttr: string;\n  tipKeyAttr: string;\n  matchAttr: string;\n  iconAttr: string;\n  currentTarget?: TargetInfo;\n  onLinkInserted?: (args: { text: string; slug: string; id: string; icon?: string }) => void;\n}\n\nfunction transformSegment(args: TransformSegmentArgs): { nodes: PhrasingContent[]; changed: boolean } {\n  const { text, matcher, claimMap, componentName, toAttr, tipKeyAttr, matchAttr, iconAttr, currentTarget, onLinkInserted } = args;\n\n  if (!text) return { nodes: [], changed: false };\n\n  const matches = matcher.findAll(text);\n  if (!matches.length) {\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  const newChildren: PhrasingContent[] = [];\n  let cursor = 0;\n  let anyLinkInserted = false;\n\n  for (const m of matches) {\n    const start = m.start;\n    const end = m.end;\n    if (start > cursor) newChildren.push({ type: 'text', value: text.slice(cursor, start) } as Text);\n\n    let id = '';\n    let slug = '';\n    let icon: string | undefined = undefined;\n    {\n      const parts = m.key.split('::');\n      id = parts[0] ?? '';\n      slug = parts[1] ?? '';\n      icon = parts[2] || undefined;\n      const claimers = claimMap.get(m.term.toLocaleLowerCase());\n      if (claimers && claimers.length > 1) {\n        const chosen = claimers[0];\n        id = chosen.id;\n        slug = chosen.slug;\n        icon = chosen.icon;\n      }\n    }\n\n    if (currentTarget && id && currentTarget.id === id) {\n      newChildren.push({ type: 'text', value: text.slice(start, end) } as Text);\n    } else {\n      const element = toMdxJsxTextElement(\n        componentName,\n        { [toAttr]: slug, [tipKeyAttr]: id, [matchAttr]: m.text, [iconAttr]: icon },\n        m.text\n      );\n      newChildren.push(element as any);\n      anyLinkInserted = true;\n      if (onLinkInserted) onLinkInserted({ text: m.text, slug, id, icon });\n    }\n\n    cursor = end;\n  }\n\n  if (cursor < text.length) newChildren.push({ type: 'text', value: text.slice(cursor) } as Text);\n\n  if (!anyLinkInserted) {\n    return { nodes: [{ type: 'text', value: text } as Text], changed: false };\n  }\n\n  return { nodes: newChildren, changed: true };\n}\n\ninterface FindCurrentTargetArgs {\n  file: any;\n  index: IndexProvider;\n  targetByPath: Map<string, TargetInfo>;\n  targetById: Map<string, TargetInfo>;\n  targetBySlug: Map<string, TargetInfo>;\n}\n\nfunction findCurrentTarget(args: FindCurrentTargetArgs): TargetInfo | undefined {\n  const { file, index, targetByPath, targetById, targetBySlug } = args;\n\n  const pathCandidates = new Set<string>();\n  const viaIndex = index.getCurrentFilePath(file as any);\n  if (typeof viaIndex === 'string') pathCandidates.add(viaIndex);\n  if (typeof file?.path === 'string') pathCandidates.add(file.path);\n  if (Array.isArray(file?.history)) {\n    for (const entry of file.history) {\n      if (typeof entry === 'string') pathCandidates.add(entry);\n    }\n  }\n\n  for (const candidate of pathCandidates) {\n    const key = normalizePath(candidate);\n    if (!key) continue;\n    const direct = targetByPath.get(key);\n    if (direct) return direct;\n    for (const [pathKey, target] of targetByPath) {\n      if (pathKey.endsWith(key) || key.endsWith(pathKey)) {\n        return target;\n      }\n    }\n  }\n\n  const data = file?.data ?? {};\n  const idCandidates = new Set<string>();\n  const slugCandidates = new Set<string>();\n\n  const pushId = (value: unknown) => {\n    if (typeof value === 'string' && value.trim()) idCandidates.add(value.trim());\n  };\n  const pushSlug = (value: unknown) => {\n    if (typeof value === 'string' && value.trim()) slugCandidates.add(value.trim());\n  };\n\n  pushId((data as any).id);\n  pushId((data as any).docId);\n  pushId((data as any).unversionedId);\n  pushSlug((data as any).slug);\n  pushSlug((data as any).permalink);\n\n  const frontMatter = (data as any).frontMatter ?? {};\n  pushId(frontMatter?.id);\n  pushSlug(frontMatter?.slug);\n  pushSlug(frontMatter?.permalink);\n\n  for (const id of idCandidates) {\n    const target = targetById.get(id);\n    if (target) return target;\n  }\n\n  for (const slug of slugCandidates) {\n    const target = targetBySlug.get(slug);\n    if (target) return target;\n  }\n\n  return undefined;\n}\n","import remarkSmartlinker from './transform.js';\nexport default remarkSmartlinker;\nexport * from './matcher.js';\n","import remarkSmartlinkerImpl from '../../../remark-smartlinker/src/index.js';\n\ntype MaybeFunction = typeof remarkSmartlinkerImpl extends (...args: any[]) => any\n  ? typeof remarkSmartlinkerImpl\n  : never;\n\ntype ResolvedAttacher = MaybeFunction extends never ? typeof remarkSmartlinkerImpl : MaybeFunction;\n\nconst attacher: ResolvedAttacher = remarkSmartlinkerImpl as ResolvedAttacher;\n\nexport default attacher;\n\nexport * from '../../../remark-smartlinker/src/index.js';\n"]}